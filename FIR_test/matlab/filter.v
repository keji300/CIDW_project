// -------------------------------------------------------------
//
// Module: filter
// Generated by MATLAB(R) 9.0 and the Filter Design HDL Coder 3.0.
// Generated on: 2019-03-15 11:43:14
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// MultiplierInputPipeline: 1
// MultiplierOutputPipeline: 1
// TargetDirectory: D:\FPGA_CIDW\FIR_test
// TargetLanguage: Verilog
// TestBenchStimulus: impulse step ramp chirp noise 

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Multipliers           : 9
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Filter (real)
// -------------------------------
// Filter Structure  : Direct-Form FIR
// Filter Length     : 9
// Stable            : Yes
// Linear Phase      : Yes (Type 1)
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module filter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] filter_in; //double
  output  [63:0] filter_out; //double

////////////////////////////////////////////////////////////////
//Module Architecture: filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter coeff1 = -3.2520274817650886E-02; //double
  parameter coeff2 = -3.8393343465239559E-02; //double
  parameter coeff3 = 7.8426769306951416E-02; //double
  parameter coeff4 = 2.8743763832233782E-01; //double
  parameter coeff5 = 3.9843109981610109E-01; //double
  parameter coeff6 = 2.8743763832233782E-01; //double
  parameter coeff7 = 7.8426769306951416E-02; //double
  parameter coeff8 = -3.8393343465239559E-02; //double
  parameter coeff9 = -3.2520274817650886E-02; //double

  // Signals
  real delay_pipeline [0:8] ; // double
  real product9; // double
  real delay_pipeline_8_under_pipe; // double
  real coeff9_pipe; // double
  real product9_pipe; // double
  real product8; // double
  real delay_pipeline_7_under_pipe; // double
  real coeff8_pipe; // double
  real product8_pipe; // double
  real product7; // double
  real delay_pipeline_6_under_pipe; // double
  real coeff7_pipe; // double
  real product7_pipe; // double
  real product6; // double
  real delay_pipeline_5_under_pipe; // double
  real coeff6_pipe; // double
  real product6_pipe; // double
  real product5; // double
  real delay_pipeline_4_under_pipe; // double
  real coeff5_pipe; // double
  real product5_pipe; // double
  real product4; // double
  real delay_pipeline_3_under_pipe; // double
  real coeff4_pipe; // double
  real product4_pipe; // double
  real product3; // double
  real delay_pipeline_2_under_pipe; // double
  real coeff3_pipe; // double
  real product3_pipe; // double
  real product2; // double
  real delay_pipeline_1_under_pipe; // double
  real coeff2_pipe; // double
  real product2_pipe; // double
  real product1_cast; // double
  real product1; // double
  real delay_pipeline_0_under_pipe; // double
  real coeff1_pipe; // double
  real product1_pipe; // double
  real sum1; // double
  real sum2; // double
  real sum3; // double
  real sum4; // double
  real sum5; // double
  real sum6; // double
  real sum7; // double
  real sum8; // double
  real output_typeconvert; // double
  real output_register; // double

  // Block Statements
  always @( posedge clk or posedge reset)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0.0000000000000000E+00;
        delay_pipeline[1] <= 0.0000000000000000E+00;
        delay_pipeline[2] <= 0.0000000000000000E+00;
        delay_pipeline[3] <= 0.0000000000000000E+00;
        delay_pipeline[4] <= 0.0000000000000000E+00;
        delay_pipeline[5] <= 0.0000000000000000E+00;
        delay_pipeline[6] <= 0.0000000000000000E+00;
        delay_pipeline[7] <= 0.0000000000000000E+00;
        delay_pipeline[8] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline[0] <= $bitstoreal(filter_in);
          delay_pipeline[1] <= delay_pipeline[0];
          delay_pipeline[2] <= delay_pipeline[1];
          delay_pipeline[3] <= delay_pipeline[2];
          delay_pipeline[4] <= delay_pipeline[3];
          delay_pipeline[5] <= delay_pipeline[4];
          delay_pipeline[6] <= delay_pipeline[5];
          delay_pipeline[7] <= delay_pipeline[6];
          delay_pipeline[8] <= delay_pipeline[7];
        end
      end
    end // Delay_Pipeline_process


  always @ (posedge clk or posedge reset)
    begin: temp_process1
      if (reset == 1'b1) begin
        delay_pipeline_8_under_pipe <= 0.0000000000000000E+00;
        coeff9_pipe <= 0.0000000000000000E+00;
        product9_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_8_under_pipe <= delay_pipeline[8];
          coeff9_pipe <= coeff9;

          product9_pipe <= delay_pipeline_8_under_pipe * coeff9_pipe;

        end
      end
    end // temp_process1

  always @* product9 <= product9_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process2
      if (reset == 1'b1) begin
        delay_pipeline_7_under_pipe <= 0.0000000000000000E+00;
        coeff8_pipe <= 0.0000000000000000E+00;
        product8_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_7_under_pipe <= delay_pipeline[7];
          coeff8_pipe <= coeff8;

          product8_pipe <= delay_pipeline_7_under_pipe * coeff8_pipe;

        end
      end
    end // temp_process2

  always @* product8 <= product8_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process3
      if (reset == 1'b1) begin
        delay_pipeline_6_under_pipe <= 0.0000000000000000E+00;
        coeff7_pipe <= 0.0000000000000000E+00;
        product7_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_6_under_pipe <= delay_pipeline[6];
          coeff7_pipe <= coeff7;

          product7_pipe <= delay_pipeline_6_under_pipe * coeff7_pipe;

        end
      end
    end // temp_process3

  always @* product7 <= product7_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process4
      if (reset == 1'b1) begin
        delay_pipeline_5_under_pipe <= 0.0000000000000000E+00;
        coeff6_pipe <= 0.0000000000000000E+00;
        product6_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_5_under_pipe <= delay_pipeline[5];
          coeff6_pipe <= coeff6;

          product6_pipe <= delay_pipeline_5_under_pipe * coeff6_pipe;

        end
      end
    end // temp_process4

  always @* product6 <= product6_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process5
      if (reset == 1'b1) begin
        delay_pipeline_4_under_pipe <= 0.0000000000000000E+00;
        coeff5_pipe <= 0.0000000000000000E+00;
        product5_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_4_under_pipe <= delay_pipeline[4];
          coeff5_pipe <= coeff5;

          product5_pipe <= delay_pipeline_4_under_pipe * coeff5_pipe;

        end
      end
    end // temp_process5

  always @* product5 <= product5_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process6
      if (reset == 1'b1) begin
        delay_pipeline_3_under_pipe <= 0.0000000000000000E+00;
        coeff4_pipe <= 0.0000000000000000E+00;
        product4_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_3_under_pipe <= delay_pipeline[3];
          coeff4_pipe <= coeff4;

          product4_pipe <= delay_pipeline_3_under_pipe * coeff4_pipe;

        end
      end
    end // temp_process6

  always @* product4 <= product4_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process7
      if (reset == 1'b1) begin
        delay_pipeline_2_under_pipe <= 0.0000000000000000E+00;
        coeff3_pipe <= 0.0000000000000000E+00;
        product3_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_2_under_pipe <= delay_pipeline[2];
          coeff3_pipe <= coeff3;

          product3_pipe <= delay_pipeline_2_under_pipe * coeff3_pipe;

        end
      end
    end // temp_process7

  always @* product3 <= product3_pipe;


  always @ (posedge clk or posedge reset)
    begin: temp_process8
      if (reset == 1'b1) begin
        delay_pipeline_1_under_pipe <= 0.0000000000000000E+00;
        coeff2_pipe <= 0.0000000000000000E+00;
        product2_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_1_under_pipe <= delay_pipeline[1];
          coeff2_pipe <= coeff2;

          product2_pipe <= delay_pipeline_1_under_pipe * coeff2_pipe;

        end
      end
    end // temp_process8

  always @* product2 <= product2_pipe;


  always @* product1_cast <= product1;


  always @ (posedge clk or posedge reset)
    begin: temp_process9
      if (reset == 1'b1) begin
        delay_pipeline_0_under_pipe <= 0.0000000000000000E+00;
        coeff1_pipe <= 0.0000000000000000E+00;
        product1_pipe <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline_0_under_pipe <= delay_pipeline[0];
          coeff1_pipe <= coeff1;

          product1_pipe <= delay_pipeline_0_under_pipe * coeff1_pipe;

        end
      end
    end // temp_process9

  always @* product1 <= product1_pipe;


  always @* sum1 <= product1_cast + product2;

  always @* sum2 <= sum1 + product3;

  always @* sum3 <= sum2 + product4;

  always @* sum4 <= sum3 + product5;

  always @* sum5 <= sum4 + product6;

  always @* sum6 <= sum5 + product7;

  always @* sum7 <= sum6 + product8;

  always @* sum8 <= sum7 + product9;

  always @* output_typeconvert <= sum8;


  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = $realtobits(output_register);
endmodule  // filter
